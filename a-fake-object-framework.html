<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Required meta tags always come first -->
  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <title>
A Fake Object Framework |         b3m2a1

</title>
  <link rel="canonical" href="https://www.wolframcloud.com/objects/b3m2a1/home/a-fake-object-framework.html">

  <link rel="alternate" type="application/atom+xml" href="https://www.wolframcloud.com/objects/b3m2a1/home/feeds/all.atom.xml" title="Full Atom Feed">

  <link rel="apple-touch-icon" href="https://www.wolframcloud.com/objects/b3m2a1/home/apple-touch-icon.png" sizes="180x180">
  <link rel="icon" type="image/png" href="https://www.wolframcloud.com/objects/b3m2a1/home/favicon-32x32.png" sizes="32x32">
  <link rel="icon" type="image/png" href="https://www.wolframcloud.com/objects/b3m2a1/home/favicon-16x16.png" sizes="16x16">
  <link rel="manifest" href="https://www.wolframcloud.com/objects/b3m2a1/home/manifest.json">
  <meta name="theme-color" content="#333333">

  <link rel="stylesheet" href="https://www.wolframcloud.com/objects/b3m2a1/home/theme/css/bootstrap.css">
  <link rel="stylesheet" href="https://www.wolframcloud.com/objects/b3m2a1/home/theme/css/font-awesome.css">
  <link rel="stylesheet" href="https://www.wolframcloud.com/objects/b3m2a1/home/theme/css/style.css">


<meta name="description" content="I promised in my post on chemistry and objects that I’d walk through the details of building an object framework in Mathematica so here we are. For those who would like to follow along, here is the package that implements this framework. Just as a quick refresher, there were …">

<link href="https://www.wolframcloud.com/objects/b3m2a1/home/theme/prettify/styles/prettify-mma.min.css" rel="stylesheet">
<script src="https://www.wolframcloud.com/objects/b3m2a1/home/theme/prettify/src/prettify.js"></script>
<!-- <script src="https://www.wolframcloud.com/objects/b3m2a1/home/theme/prettify/src/lang-mma.min.js"></script> -->

<script>
  function moveWindow (){window.location.hash="main-content";}
</script>


<script>
  (function(i, s, o, g, r, a, m) {
    i['GoogleAnalyticsObject'] = r;
    i[r] = i[r] || function() {
      (i[r].q = i[r].q || []).push(arguments)
    }, i[r].l = 1 * new Date();
    a = s.createElement(o);
    a.async = 1;
    a.src = g;
    m = s.getElementsByTagName(o)[0];
    m.parentNode.insertBefore(a, m)
  })(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');
  ga('create', 'UA-103560228-1', 'auto');
  ga('send', 'pageview');
</script>

  <script>
    function openNav() {
      var thumb = document.getElementById("nav-thumb");
      var bar = document.getElementById("side-nav");
      thumb.onclick= closeNav;
      bar.classList.add("right-bar-open");
      bar.classList.remove("right-bar-closed");
      thumb.classList.add("nav-thumb-open");
      thumb.classList.remove("nav-thumb-closed");
    }

    function closeNav() {
      var thumb = document.getElementById("nav-thumb");
      var bar = document.getElementById("side-nav");
      thumb.onclick= openNav;
      bar.classList.remove("right-bar-open");
      bar.classList.add("right-bar-closed");
      thumb.classList.remove("nav-thumb-open");
      thumb.classList.add("nav-thumb-closed")
    }
  </script>


</head>

<body onload="PR.prettyPrint(); moveWindow()"
>
  <header class="header">
    <div class="top-bar">
    <div class="site-image">
      <img src=https://www.wolframcloud.com/objects/b3m2a1/home/img/site-image.png alt="b3m2a1">
    </div>
    <div class="site-links bubble floating">
      <h1 class="title">
          <a href="https://www.wolframcloud.com/objects/b3m2a1/home/">
            b3m2a1
          </a>
        </h1>
        <ul
          class="list-inline row site-link-row"
          id="top-bar-link-row"
          >
            <li class="list-inline-item site-link">
              <a href="https://www.wolframcloud.com/objects/b3m2a1/home/pages/about.html">About</a>
            </li>
            <li class="list-inline-item site-link">
              <a href="https://www.wolframcloud.com/objects/b3m2a1/home/pages/contact.html">Contact</a>
            </li>
            <li class="list-inline-item site-link">
              <a href="https://www.wolframcloud.com/objects/b3m2a1/home/categories.html">Categories</a>
            </li>
            <li class="list-inline-item site-link">
              <a href="https://www.wolframcloud.com/objects/b3m2a1/home/tags.html">Tags</a>
            </li>
            <li class="list-inline-item site-link">
              <a href="https://www.wolframcloud.com/objects/b3m2a1/home/archives.html">Archives</a>
            </li>
        </ul>
    </div>
    </div>
  </header>

  <div class="main" id="main-content">

    <div class="right-bar right-bar-closed" id="side-nav">
      <button
        id="nav-thumb"
        class="nav-thumb nav-thumb-closed"
        onclick="openNav()"
        >
      </button>
      <div class="blogroll bubble inset">
        <p>Links</p>
        <ul class="blogroll-links right-bar-links list-inline">
            <li class="right-bar-item">
              <a href="https://github.com/b3m2a1" class="blogroll-link right-bar-link"
                target="_blank">
                GitHub
              </a>
            </li>
            <li class="right-bar-item">
              <a href="https://mathematica.stackexchange.com/users/38205" class="blogroll-link right-bar-link"
                target="_blank">
                StackExchange
              </a>
            </li>
            <li class="right-bar-item">
              <a href="https://www.wolframcloud.com/objects/b3m2a1.paclets/PacletServer/main.html" class="blogroll-link right-bar-link"
                target="_blank">
                Paclets
              </a>
            </li>
            <li class="right-bar-item">
              <a href="https://www.wolframcloud.com/objects/b3m2a1.docs/DocumentationSite/main.html" class="blogroll-link right-bar-link"
                target="_blank">
                Docs
              </a>
            </li>
          </ul>
      </div>
    </div>

    <div class="left-content">
      <div class="container">
        <h1>A Fake Object Framework
</h1>
        <hr>
<article class="article">
  <header>
    <ul class="list-inline">
      <li class="list-inline-item text-muted" title="2017-08-04T17:57:46-05:00">
        <i class="fa fa-clock-o"></i>
        Fri 04 August 2017
      </li>
      <li class="list-inline-item">
        <i class="fa fa-folder-open-o"></i>
        <a href="https://www.wolframcloud.com/objects/b3m2a1/home/category/posts.html">posts</a>
      </li>
      <li class="list-inline-item">
        <i class="fa fa-user-o"></i>
        <a href="https://www.wolframcloud.com/objects/b3m2a1/home/author/b3m2a1.html">b3m2a1</a>      </li>
      <li class="list-inline-item">
        <i class="fa fa-files-o"></i>
        <a href="https://www.wolframcloud.com/objects/b3m2a1/home/tag/mathematica.html">#mathematica</a>      </li>
    </ul>
  </header>
  <div class="content">
    <p>I promised in my post on  <a href="https://www.wolframcloud.com/objects/b3m2a1/home/-pretend-chemistry-and-fake-objects.html">chemistry and objects</a>  that I’d walk through the details of building an object framework in Mathematica so here we are. For those who would like to follow along,  <a href="https://github.com/b3m2a1/mathematica-ObjectFramework/blob/master/Packages/ObjectFramework.m">here</a>  is the package that implements this framework.</p>
<p>Just as a quick refresher, there were a few properties that we decided we’d use in our framework. These were:</p>
<ul>
<li>
<p>Objects are glorified hash-maps</p>
</li>
<li>
<p>Objects have types</p>
</li>
<li>
<p>Methods get bound to objects</p>
</li>
<li>
<p>There are properties which are bound methods that evaluate when accessed</p>
</li>
<li>
<p>Everything important is vectorized (i.e. can be done over vectors)</p>
</li>
</ul>
<p>We’ll start with the first of those.</p>
<p><a id="building-an-object" >&zwnj;</a></p>
<h2>Building an Object</h2>
<h3>Objects as Hash Maps</h3>
<p>A  <a href="https://en.wikipedia.org/wiki/Hash_table">hash-map</a>  is a data structure that provides very efficient look-up and insertion. Both of these will be crucial for us. Mathematica’s top-level version of as hash-map is called an  <a href="https://reference.wolfram.com/language/ref/Association.html"><code>Association</code></a> . So we’ll simply store all object data in one of these. With that in mind, we could then go one of three routes:</p>
<ul>
<li>
<p>Each object stores its data in a symbol it holds</p>
</li>
<li>
<p>All object data is stored in a single symbol</p>
</li>
<li>
<p>Each object stores its data in a symbol and there’s a central store for all these symbols</p>
</li>
</ul>
<p>For reasons of convenience we will choose the second. If there will be massive amounts of object data store the last may be the best, performance wise, but provides somewhat more involved property setting. The first makes it hard to know what exactly is an object. Both the first and last similarly make restoring state somewhat more challenging.</p>
<p>So we’ll initialize an  <code>Association</code>  for storing all of our data:</p>
<pre class="prettyprint"><code>$OFObjectTable = &lt;|

   &quot;Types&quot; -&gt; &lt;|
        &quot;Object&quot; -&gt; &lt;||&gt;
        |&gt;,
     &quot;Objects&quot; -&gt; &lt;||&gt;
     |&gt;;</code></pre>


<p>Note that we have two sub-maps, one for basic type data, one for object data. This leads us to the second point on that list, “Objects have types”. But before we even get there, we’ll need to look at how we define our objects.</p>
<h3>Object Creation</h3>
<p>Now that we know how we’ll store our objects, the question is how should we build a new one. Since we’re working with an  <code>Association</code>  we need some a way to define a unique key for each object. There are a few possible routes here, but the one I’ve found to be easiest works through  <a href="https://reference.wolfram.com/language/ref/CreateUUID.html"><code>CreateUUID</code></a>  for the following reasons:</p>
<ul>
<li>
<p>It's essentially assured to be universally unique, which makes storage and recall easy</p>
</li>
<li>
<p>The keys are strings, so assured to be without side effects</p>
</li>
<li>
<p>We can attach little meta-tags to the front of the key to give us a hint of what we’re working with</p>
</li>
</ul>
<p>For our object definitions we’ll take an  <code>Association</code>  of properties as the core data, where we extract the type from the  <code>"ObjectType"</code>  field passed. Since it’s vectorized we’ll write it with a  <code>List</code>  of  <code>Association</code>  objects in mind:</p>
<pre class="prettyprint"><code>Options[OFNewObject] =
   {
     &quot;Initialize&quot; -&gt; True,
     &quot;UUIDMethod&quot; -&gt; (CreateUUID[# &lt;&gt; &quot;-&quot;] &amp;)
     };
OFNewObject[objs : {__Association}, ops : OptionsPattern[]] :=

  Catch@
    Module[{
       types = Lookup[objs, &quot;ObjectType&quot;, &quot;Object&quot;],
       args = Lookup[objs, &quot;ObjectInitializationArguments&quot;, {}],
       uuids,
       objlist
       },
      If[! AllTrue[types, StringQ], 
     Message[OFNewObject::types, types]; Throw[$Failed]];
      uuids =
        MapIndexed[
          OptionValue[&quot;UUIDMethod&quot;],
          types
          ];
      If[! AllTrue[uuids, StringQ], 
     Message[OFNewObject::uuids, uuids]; Throw[$Failed]];
      objlist = OFObject /@ uuids;
      AssociateTo[$OFObjectTable[&quot;Objects&quot;],
        MapThread[
          #3 -&gt;
             Join[
               #,
               &lt;|
                 &quot;ObjectType&quot; -&gt; #2,
                 &quot;ObjectID&quot; -&gt; #3
                 |&gt;
               ] &amp;,
          {
            KeyDrop[objs, &quot;ObjectInitializationArguments&quot;],
            types,
            uuids
            }]
        ];
      If[OptionValue[&quot;Initialize&quot;],
        MapThread[
          Function[# @@ #2],
          {
            OFLookup[objlist, &quot;ObjectInitialization&quot;, Identity],
            args
            }]
        ];
      objlist
     ];</code></pre>


<p>What this does is determines the type for each object, creates a new UUID for each, sticks  <code>UUID -&gt; Association</code>  pairs into the  <code>$OFObjectTable</code>  and then calls an  <code>"ObjectInitialization"</code>  function on each with some collection of passed arguments, assuming it’s been defined. Then it wraps all the new UUIDs in an  <code>OFObject</code>  head and spits them back out.</p>
<p>One thing to notice is that this is actually already boot-strapping. We call the standard object framework lookup function,  <code>OFLookup</code> , in the definition process.</p>
<p>Then, since making new objects like this is a little bit unwieldy to use, we’ll put some syntactic sugar on it:</p>
<pre class="prettyprint"><code>OFNewObject[a : {((_String -&gt; _Association) | _String) ..}] :=

  OFNewObject@
     Map[
       If[Length[#] == 2,
          Append[#[[2]], &quot;ObjectType&quot; -&gt; #[[1]]],
          &lt;|&quot;ObjectType&quot; -&gt; #|&gt;
          ] &amp;,
       a];
OFNewObject[
   a : _Association | _String | (_String -&gt; _Association)] :=

  First@OFNewObject[{a}];</code></pre>


<p>These two make creating new objects just a little bit nicer. </p>
<p>Even the vectorized form is a little bit slow:</p>
<pre class="prettyprint"><code>RepeatedTiming[
  objs = OFNewObject[ConstantArray[&quot;Object&quot;, 100000]];] // First

(*Out:*)

2.55</code></pre>


<p>But that’s largely unavoidable. It can be sped up somewhat by providing precomputed UUIDs:</p>
<pre class="prettyprint"><code>With[{uuids = ToString /@ Range[100000]},
  RepeatedTiming[
     objs =
        OFNewObject[ConstantArray[&quot;Object&quot;, 100000],
          &quot;UUIDMethod&quot; -&gt; (uuids[[First@#2]] &amp;)
          ];] // First
  ]

(*Out:*)

1.82</code></pre>


<p>Or by specifying no initialization should happen:</p>
<pre class="prettyprint"><code>RepeatedTiming[
   objs =
      OFNewObject[ConstantArray[&quot;Object&quot;, 100000],
        &quot;Initialize&quot; -&gt; False
        ];] // First

(*Out:*)

1.97</code></pre>


<p>But beyond that there’s not much one can do.</p>
<h3>Object Types, Part 1</h3>
<p>In our setup, types serve as meta objects, from which instances inherit property and are spawned. We’ll implement a single-inheritance scheme, since I’m lazy. Our types will live in the  <code>"Types"</code>  sub- <code>Association</code>  of our  <code>$OFObjectTable</code> . They will function almost exactly like objects, though.</p>
<p>We’ll get into a larger discussion about them later</p>
<p><a id="object-basics" >&zwnj;</a></p>
<h2>Object Basics</h2>
<h3>Property Lookup</h3>
<p>This is the heart of the project, from which everything else will derive. Our lookup will be implemented in a vectorized manner, layered on  <a href="https://reference.wolfram.com/language/ref/Lookup.html"><code>Lookup</code></a> . Our base case will just be looking up a raw object  <code>Association</code> . But first, since we noted our types will work like objects, we need a nice way to do lookups on either. The way we’ll do that is through a variable  <code>$OFLookupGroup</code>  which will be  <code>"Objects"</code>  or  <code>"Types"</code> . Now for the raw data lookup:</p>
<pre class="prettyprint"><code>OFLookup[k_String | OFObject[k_String]] :=

  Lookup[$OFObjectTable[$OFLookupGroup], k];
OFLookup[k : {__String}] :=

  Lookup[$OFObjectTable[$OFLookupGroup], k];
OFLookup[k : {__OFObject}] :=

  Lookup[$OFObjectTable[$OFLookupGroup], First /@ k];</code></pre>


<p>That’s trivial, of course, so we move on to a property lookup:</p>
<pre class="prettyprint"><code>OFLookup[
    keys : {__String}, p_,
    default_: Missing[&quot;KeyAbsent&quot;]] :=
   MapThread[
     OFPostLookup,
     {
       OFRecursiveLookup[
         Lookup[$OFObjectTable[$OFLookupGroup], keys],
         p,
         default
         ],
       keys
       }
     ];</code></pre>


<p>Note that the heart of this is really missing. We need the following two functions to truly know what’s up. One for vectorized recursive lookups:</p>
<pre class="prettyprint"><code>OFRecursiveLookup[
    objs : {__Association},
    keys_,
    default_: $OFMissingKeyAbsent
    ] :=
   Module[{
      missingKey = Unique[$OFMissingKeyAbsent],
      types =
        Lookup[objs, &quot;ObjectType&quot;, &quot;Object&quot;],
      typeroot = Lookup[$OFObjectTable[&quot;Types&quot;], &quot;Object&quot;, &lt;||&gt;]
      },
     types =
       Lookup[$OFObjectTable[&quot;Types&quot;], types, typeroot];
     If[default === $OFMissingKeyAbsent,
        Map[
          If[ListQ@keys,
             MapThread[
               If[# === missingKey,
                  Missing[&quot;KeyAbsent&quot;, #2],
                  #
                  ] &amp;,
               {
                 #,
                 keys
                 }
               ],
             If[# === missingKey,
               Missing[&quot;KeyAbsent&quot;, keys],
               #
               ]
             ] &amp;
          ],
        Identity
        ]@
       Replace[
         OFrecursiveLookupStep[objs, types, keys, default, missingKey,
       typeroot],
         missingKey -&gt; default,
         {2}
         ]
     ];
(*Recursive lookup step*)
OFrecursiveLookupStep[
    objs_,
    types_,
    keys_,
    default_,
    missing_,
    typeroot_
    ] :=
   Module[{
      props = Lookup[objs, keys, missing],
      missingpos,
      objnew,
      typenew
      },
     missingpos = First /@ Position[props, missing, {1}];
     objnew = DeleteCases[types[[missingpos]], typeroot];
     If[Length@objnew == 0,
       props,
       typenew =
         Lookup[
           $OFObjectTable[&quot;Types&quot;],
           Lookup[objnew, &quot;ObjectType&quot;, &quot;Object&quot;],
           typeroot
           ];
       ReplacePart[props,
         Thread[

      missingpos -&gt;

       OFrecursiveLookupStep[objnew, typenew, keys, default, missing, 
        typeroot]
           ]
         ]
       ]
     ];</code></pre>


<p>And one for post-processing our lookups:</p>
<pre class="prettyprint"><code>OFPostLookup[e_OFMethod, id_] :=
   If[$OFPrepMethods // TrueQ,
     OFPrepMethod[e, id],
     e
     ];
OFPostLookup[l : _List, id_] :=
   OFPostLookup[#, id] &amp; /@ l;
OFPostLookup[e : Except[_OFMethod | _List], id_] :=
   e;
(*Method binding*)

OFPrepMethod[OFMethod[f_, a_Association], id_String] :=
   With[{
      atts = Lookup[a, &quot;Attributes&quot;, {HoldAllComplete}],
      autoEval = Lookup[a, &quot;Evaluate&quot;, False],
      obj =
        Replace[
          Lookup[a, &quot;PassFirst&quot;, OFObject@id], {
            OFType | &quot;ObjectType&quot; :&gt;
              OFType@Lookup[id, &quot;ObjectType&quot;, &quot;Object&quot;],
            None :&gt;
              Sequence[]
           }]},
     If[autoEval,
       f[obj],
       Function[Null, f[obj, ##], atts]
       ]
     ];
OFPrepMethod[OFMethod[f_], id_String] :=
   With[{obj = OFObject@id},
     Function[Null, f[obj, ##], HoldAllComplete]
     ];</code></pre>


<p>Where that  <code>OFPrepMethod</code>  is a function that will bind an  <code>OFMethod</code>  to an object instance via a pure  <code>Function</code></p>
<p>Now we see where that  <code>"ObjectType"</code>  comes in.  <code>OFRecursiveLookup</code>  will recurse through an object’s ancestors until it hits no more ancestors or it hits the property.</p>
<h3>Application</h3>
<p>All of our setting / getting will be defined in terms of object mutations. The basic idea is that we’ll define a single function,  <code>OFApply</code> , which will get parts of an object, and apply a function to them. And then do this in a vectorized way. We can then define a function  <code>OFMutate</code>  on that that automatically calls  <code>Set</code>  on the result.</p>
<p>We’ll need, once again, a symbol to tell us whether we’re working with the  <code>"Objects"</code>  or  <code>"Types"</code>  which we’ll call  <code>$OFApplicationGroup</code> . Then the heart of the function looks like this:</p>
<pre class="prettyprint"><code>OFApply[k : {__String}, f_] :=

  With[{$OFApplicationGroup = $OFApplicationGroup},
     If[KeyMemberQ[$OFObjectTable[$OFApplicationGroup], #],
         f[
           $OFObjectTable[$OFApplicationGroup, #],
           HoldPattern[$OFObjectTable[$OFApplicationGroup, #]]
           ],
         Missing[&quot;KeyAbsent&quot;, #]
         ] &amp; /@ k
     ];
OFApply[k : {__String}, p_, f_] :=

  With[{$OFApplicationGroup = $OFApplicationGroup},
     If[KeyMemberQ[$OFObjectTable[$OFApplicationGroup], #],
         f[
           OFLookup[#, p],
           HoldPattern[$OFObjectTable[$OFApplicationGroup, #, p]]
           ],
         Missing[&quot;KeyAbsent&quot;, #]
         ] &amp; /@ k
     ];</code></pre>


<p>Where we actually have two different cases. One where there’s no property to apply to, and one where there is. Branching it like this simplifies the definition process and lets us speed up each. Note that the actual group to be assigned to is passed in the second symbol, to make things easier in setting, etc.</p>
<h3>Property Setting</h3>
<p>We can then define a  <code>OFSet</code>  function and friends off of an  <code>OFApply</code>  call. In fact, the entire function is just this:</p>
<pre class="prettyprint"><code>OFSet[k : objectPattern, p : Except[_List], v_] :=
   OFApply[k, p,
     Function[Null,
       Set[#2, v],
       HoldFirst
       ]
     ];</code></pre>


<p>In fact, it’s just a  <code>Set</code>  delegate.</p>
<p>And then we can define a number of other such delegates, say for  <code>SetDelayed</code></p>
<pre class="prettyprint"><code>OFSetDelayed[k : objectPattern, p_, v_] :=
   OFApply[k, p,
     Function[Null,
       SetDelayed[#2, v],
       HoldAllComplete
       ]
     ];
OFSetDelayed~SetAttributes~HoldAllComplete</code></pre>


<p>Or a threaded  <code>Set</code>  (with a delayed companion):</p>
<pre class="prettyprint"><code>OFSetThread[k : objectPattern, p_, v_] :=

  With[{base = Thread[p -&gt; v]},
     OFApply[k,
       Function[Null,
         AssociateTo[Evaluate@Extract[#2, 1, Unevaluated], base],
         HoldAllComplete
         ]
       ];
     v
     ];</code></pre>


<p>Or on a  <code>Part</code>  (again, with a delayed companion)</p>
<pre class="prettyprint"><code>OFSetPart[k : objectPattern, key_, parts__, value_] :=

 OFApply[k, key,
    Function[Null,
      Replace[Unevaluated[#],
        HoldPattern[$OFObjectTable[p__]] :&gt;

     Set[$OFObjectTable[[p, parts]], value]
        ],
      HoldAllComplete
      ]
    ]</code></pre>


<p>And so forth.</p>
<h3>Simplified Mutation Syntax</h3>
<p>We can then take advantage of  <code>Language`SetMutationHandler</code>  to mutate these objects from a  <code>Symbol</code>  without going through an  <a href="https://reference.wolfram.com/language/ref/Evaluate.html"><code>Evaluate</code></a>  or  <a href="https://reference.wolfram.com/language/ref/With.html"><code>With</code></a>  call. First we define our handler (note that this is only a sample defintion):</p>
<pre class="prettyprint"><code>OFObjectMutationHandler~SetAttributes~HoldAllComplete;
OFObjectMutationHandler[
    Set[t : sym_Symbol?OFTestObjectQ[base___, prop : Except[_List]], 
    newvalue_]
    ] :=
   With[{obj = sym[base]},
     If[OFObjectQ[obj],
       OFSet[obj, prop, newvalue]
       ]
     ];</code></pre>


<p>And then we set it:</p>
<pre class="prettyprint"><code>Language`SetMutationHandler[OFObject, OFObjectMutationHandler];</code></pre>


<p>And with that we can easily mutate our object with calls of the form:</p>
<pre class="prettyprint"><code>obj[&quot;prop&quot;] = val</code></pre>


<h3>Other Bits and Pieces</h3>
<p>A number of other interface functions are implemented, including  <code>AddTo</code> ,  <code>SubtractFrom</code> ,  <code>Join</code> ,  <code>Merge</code> ,  <code>Map</code>  etc.</p>
<p>Similarly, as is visible in the  <code>OFPostLookup</code>  function, there is a special head called  <code>OFMethod</code>  which binds to an object instance as a function and which can take an  <code>Association</code>  as its second argument, which allows it to be treated as a python property in terms of auto-calling.</p>
<p><a id="types" >&zwnj;</a></p>
<h2>Types</h2>
<h3>Creating Types</h3>
<p>As noted previously, we’re treating types as objects, so we’ll need a way to construct new types as well. Note, though, that this will is much simpler than making objects, as they need not be initialized and don’t need unique keys.</p>
<pre class="prettyprint"><code>OFNewType[a : {__Association}] :=
   Catch@
    With[{
       names =
         Lookup[
           a,
           &quot;ObjectTypeName&quot;
           ]
       },
      If[! AllTrue[names, StringQ], Message[OFNewType::names, names]; 
     Throw@$Failed];
      AssociateTo[
        $OFObjectTable[&quot;Types&quot;],
        Thread[names -&gt; a]
        ]
      ];</code></pre>


<p>And again we’ll provide some more convenient, non-vectorized syntax:</p>
<pre class="prettyprint"><code>OFNewType[a_Association] :=
   First@OFNewType[{a}];
OFNewType[name_String, a : _Association : &lt;||&gt;] :=
  OFNewType[
    Append[a, &quot;ObjectTypeName&quot; -&gt; name];
    ]</code></pre>


<h3>Type Instantiation</h3>
<p>So we have an object creation syntax, but it’s worth having this be derivable from an  <code>OFType</code>  as well. The simplest constructor would be simply to attach  <a href="https://www.wolframcloud.com/objects/b3m2a1.paclets/reference/ref/SubValues.html"><code>SubValues</code></a>  to the  <code>OFType</code>  symbol:</p>
<pre class="prettyprint"><code>OFType[type_][args___] :=
  OFNewObject[&lt;|
     &quot;ObjectType&quot; -&gt; type,
     &quot;ObjectInitializationArguments&quot; -&gt; HoldComplete[args]
     |&gt;]</code></pre>


<p>The issue is that  <code>SubValues</code>  of course cannot have  <a href="https://reference.wolfram.com/language/ref/Attributes.html"><code>Attributes</code></a>  so we can’t hold the arguments, and we can’t vectorize this. So we’ll also build a more robust version, deviating from python syntax, using an  <code>OFNewObject</code>  call:</p>
<pre class="prettyprint"><code>OFNewObject[types : {(Rule | RuleDelayed)[_OFType, _] ..}] :=

  OFNewObject[
     &lt;|
         &quot;ObjectType&quot; -&gt;
           #[[1, 1]],
         &quot;ObjectInitializationArguments&quot; -&gt;
           Extract[
             #,
             2,
             Function[Null,

         Replace[HoldComplete[#], 
          HoldComplete[_[a___]] :&gt; HoldComplete[a]],
               HoldAllComplete
               ]
             ]
         |&gt; &amp; /@ types
     ];
OFNewObject[
   types : {(Rule | RuleDelayed)[_OFType, _] | _OFType ..}] :=

  OFNewObject[
     Replace[types, t_OFType :&gt; (OFType -&gt; {}), 1]
     ];
OFNewObject[type : (Rule | RuleDelayed)[_OFType, _] | _OFType] :=

 First@OFNewObject[{type}]</code></pre>


<p>This way arguments can easily be specified using  <a href="https://reference.wolfram.com/language/ref/RuleDelayed.html"><code>RuleDelayed</code></a>  syntax to get holding, and it’s a clear, vectorizable syntax.</p>
<p><a id="building-a-type-constructor" >&zwnj;</a></p>
<h2>Building a Type Constructor</h2>
<p>Having to specify a type as an  <code>Association</code>  can be unwieldy, so we’ll build a package-like syntax for type definitions. The basic plan is to build and add to a construction stack until some end function is called, at which point it will unravel back out to a type.</p>
<h3>The Construction Stack</h3>
<p>This is a simple list to which pieces can be appended. We’ll instantiate it like so:</p>
<pre class="prettyprint"><code>$OFConstructorStack = {};</code></pre>


<h3>Begin</h3>
<p>We’ll then create a function like  <a href="https://reference.wolfram.com/language/ref/BeginPackage.html"><code>BeginPackage</code></a>  which will stick basic meta-information on the stack:</p>
<pre class="prettyprint"><code>Options[OFBegin] = {
    &quot;Type&quot; -&gt; &quot;Object&quot;,
    &quot;Construct&quot; -&gt; &quot;Type&quot;,
    &quot;Assign&quot; -&gt; None
    };
OFBegin[name : Except[_Rule | _RuleDelayed], 
   ops : OptionsPattern[]] :=
   AppendTo[$OFConstructorStack,
     &lt;|
       &quot;Name&quot; -&gt;
         Replace[name, None | Automatic :&gt; CreateUUID[&quot;Type-&quot;]],
       &quot;Construct&quot; -&gt;
         Replace[OptionValue[&quot;Construct&quot;], Except[&quot;Object&quot;] -&gt; &quot;Type&quot;],
       &quot;Assign&quot; -&gt;
         OptionValue[&quot;Assign&quot;],
       &quot;Fields&quot; -&gt;
         &lt;|
           &quot;ObjectType&quot; -&gt;
             Replace[OptionValue[&quot;Type&quot;],
               _?(Not@KeyMemberQ[$OFObjectTable[&quot;Types&quot;], #] &amp;) -&gt; 
         &quot;Object&quot;
               ]
           |&gt;,
       &quot;Methods&quot; -&gt;
         &lt;|
           |&gt;
       |&gt;
     ];
OFBegin~SetAttributes~HoldRest;</code></pre>


<h3>Stack Additions</h3>
<p>Then we have a function for sticking data on the stack. First one for fields:</p>
<pre class="prettyprint"><code>OFAddField[name_, value_] :=
   (
     AssociateTo[$OFConstructorStack[[-1, &quot;Fields&quot;]],
        name -&gt; value
        ];
     );
OFAddFieldDelayed[name_, value_] :=
   (
     AssociateTo[$OFConstructorStack[[-1, &quot;Fields&quot;]],
        name :&gt; value
        ];
     );</code></pre>


<p>And one for methods:</p>
<pre class="prettyprint"><code>OFAddMethod[nameProvided_, data : _Association : &lt;||&gt;] :=

  With[{name =
       Replace[nameProvided,
         s_String :&gt;
           Replace[
             StringReplace[s, {
                &quot;__&quot; ~~ l : WordCharacter .. ~~ &quot;__&quot; :&gt;

           &quot;Object&quot; &lt;&gt; ToUpperCase@StringTake[l, 1] &lt;&gt; 
            StringDrop[l, 1],
                &quot;__&quot; ~~ l : WordCharacter .. :&gt; PrivateKey[l]
                }],
             StringExpression[__, p_PrivateKey] :&gt; p
             ]
         ]},
     If[KeyMemberQ[$OFConstructorStack[[-1, &quot;Methods&quot;]], name],
       $OFConstructorStack[[-1, &quot;Methods&quot;, name, &quot;Properties&quot;]] =
         Join[
           $OFConstructorStack[[-1, &quot;Methods&quot;, name, &quot;Properties&quot;]],
           data
           ],
       AssociateTo[$OFConstructorStack[[-1, &quot;Methods&quot;]],
         name -&gt;
           &lt;|

       &quot;Symbol&quot; -&gt; OFMethodSymbol[name],
             &quot;Properties&quot; -&gt; data
             |&gt;
         ]
       ]
     ];</code></pre>


<p>Note that this uses something called  <code>OFMethodSymbol</code>  which is defined like so:</p>
<pre class="prettyprint"><code>OFMethodSymbol[name_, add : True | False : False] :=

  If[KeyMemberQ[$OFConstructorStack[[-1, &quot;Methods&quot;]], name],
     $OFConstructorStack[[-1, &quot;Methods&quot;, name, &quot;Symbol&quot;]],
     If[add,
       OFAddMethod[name];
       OFMethodSymbol[name, False],
       Symbol[
         StringReplace[ToString[name], 
       Except[WordCharacter | &quot;$&quot;] -&gt; &quot;&quot;] &lt;&gt;
           &quot;$&quot; &lt;&gt; 
      StringReplace[CreateUUID[], &quot;-&quot; -&gt; &quot;&quot;]
         ]
       ]
     ];</code></pre>


<p>Where it simply finds the symbol attached to a method on the stack. This will be more important later.</p>
<h3>Method Construction</h3>
<p>This constructor is more powerful if we provide a method construction aide or two, so we’ll do just that. First we’ll set up something to track what methods we build:</p>
<pre class="prettyprint"><code>If[! MatchQ[$OFBuiltMethods, _Association],
   $OFBuiltMethods = &lt;||&gt;
   ];</code></pre>


<p>And then a function that actually builds a method:</p>
<pre class="prettyprint"><code>OFBuildMethod[f_, data_Association] :=
  With[{
     a = Lookup[data, &quot;Attributes&quot;, {}],
     o = Lookup[data, &quot;Options&quot;, {}]
     },
    If[MatchQ[f, _Symbol],
      Attributes[f] = a;
      Options[f] = o;
      ];
    OFMethod[f, KeyDrop[data, {&quot;Attributes&quot;, &quot;Options&quot;}]]
    ]</code></pre>


<h3>End</h3>
<p>Finally we’ll have a function that takes all that stack data and converts it into a type. It simply finds all of the properties, puts them into the  <code>Association</code>  that  <code>OFNewType</code>  expects, and sends it through.</p>
<pre class="prettyprint"><code>OFEnd[] :=
   If[Length@$OFConstructorStack &gt; 0,
     With[{a = Last@$OFConstructorStack},
       $OFConstructorStack = Delete[$OFConstructorStack, -1];
       With[{
          t = a[&quot;Construct&quot;],
          s = a[&quot;Assign&quot;],
          n = a[&quot;Name&quot;],
          f = a[&quot;Fields&quot;],
          m = OFBuildMethod[#Symbol, #Properties] &amp; /@ a[&quot;Methods&quot;]
          },
         $OFBuiltMethods =
           Join[$OFBuiltMethods,
             AssociationMap[Null &amp;,
               Values@a[[&quot;Methods&quot;, All, &quot;Symbol&quot;]]
               ]
             ];
         With[{obj =
             If[t == &quot;Type&quot;,
               OFNewType[n, Join[f, m, &lt;|&quot;ObjectTypeName&quot; -&gt; n|&gt;]];
               OFType[n],
               OFNewObject[Join[f, m, &lt;|&quot;ObjectType&quot; -&gt; n|&gt;]]
               ]
            },
           If[s =!= None, s = obj, s]
           ]
         ]
       ],
     None
     ];</code></pre>


<h3>Constructor UpValues</h3>
<p>Generally we won’t want to use  <code>OFAddField</code>  or anything like that when we’re defining types. It’s just a little bit clumsy. Better, generally, is to define types in a similar style to how packages are built. What I mean is we’ll want some syntax like this:</p>
<pre class="prettyprint"><code>OFBegin[&quot;TypeName&quot;];
OFField[&quot;FieldName&quot;] = val;
SetOptions[OFMethod[&quot;MethodName&quot;], { ...}];
OFMethod[&quot;MethodName&quot;][pats___] := code;
OFEnd[];</code></pre>


<p>We can get set this up using  <code>UpValues</code> . The actually  <code>UpValues</code>  used aren’t terribly interesting so we’ll leave them out here. You can look at the implementation package if you’re interested.</p>
<h3>Magic Methods</h3>
<p>One last thing we’ll want are aliases for some so-called “magic methods”—things like  <code>"ObjectInitialization"</code>  that the framework knows to look for and which define special hooks. At the moment there are three of these:</p>
<pre class="prettyprint"><code>OFInit /:

  HoldPattern[(s : Set | SetDelayed)[OFInit[p___], code_]] :=

  s[OFMethod[&quot;ObjectInitialization&quot;][p], code];
OFRepr /:

  HoldPattern[(s : Set | SetDelayed)[OFRepr[p___], code_]] :=

  s[OFMethod[&quot;ObjectRepresentation&quot;][p], code];
OFStr /:

  HoldPattern[(s : Set | SetDelayed)[OFStr[p___], code_]] :=

  s[OFMethod[&quot;ObjectString&quot;][p], code];</code></pre>


<p><a id="an-object-framework-example" >&zwnj;</a></p>
<h1>An Object Framework Example</h1>
<p><a id="defining-a-ball-in-a-box" >&zwnj;</a></p>
<h2>Defining a Ball in a Box</h2>
<p>We’ll do a quick, simple example, where we define a ball-in-a-box class and just watch a ball bounce around a box:</p>
<p>First we begin the class:</p>
<pre class="prettyprint"><code>ballInABox := OFBegin[&quot;BallInABox&quot;]

(*Out:*)

{&lt;|&quot;Name&quot; -&gt; &quot;BallInABox&quot;, &quot;Construct&quot; -&gt; &quot;Type&quot;, 
  &quot;Assign&quot; -&gt; HoldPattern[ballInABox], 
  &quot;Fields&quot; -&gt; &lt;|&quot;ObjectType&quot; -&gt; &quot;Object&quot;|&gt;, &quot;Methods&quot; -&gt; &lt;||&gt;|&gt;}</code></pre>


<p>Add a default box and elasticity multiplier</p>
<pre class="prettyprint"><code>OFField[&quot;Box&quot;] = {{-5, 5}, {-5, 5}};
OFField[&quot;ElasticityMultiplier&quot;] = 1;</code></pre>


<p>Define a  <code>"Step"</code>  function</p>
<pre class="prettyprint"><code>OFMethod[&quot;Step&quot;][
   self_,
   time : _Quantity : Quantity[.1, &quot;Seconds&quot;],
   steps : _Integer?Positive : 1
   ] :=

 Module[{position, velocity, box, mulp, 
   timenum = QuantityMagnitude@UnitConvert[time, &quot;Seconds&quot;]}, 
    {position, velocity, box, mulp} =
      OFLookup[
    self, {&quot;Position&quot;, &quot;Velocity&quot;, &quot;Box&quot;, &quot;ElasticityMultiplier&quot;}];
    (self[{&quot;Postion&quot;, &quot;Velocity&quot;}] = {position, velocity}; #) &amp;@
      Reap[
         Do[
           position += velocity*timenum;
           Which[
             position[[1]] &lt; box[[1, 1]],
              position[[1]] = box[[1, 1]];
              velocity[[1]] = -mulp*velocity[[1]],
             position[[1]] &gt; box[[1, 2]],
              position[[1]] = box[[1, 2]];
              velocity[[1]] = -mulp*velocity[[1]]
             ];
           Which[
             position[[2]] &lt; box[[2, 1]],
              position[[2]] = box[[2, 1]];
              velocity[[2]] = -mulp*velocity[[2]],
             position[[2]] &gt; box[[2, 2]],
              position[[2]] = box[[2, 2]];
              velocity[[2]] = -mulp*velocity[[2]]
             ];
           Sow@position,
           steps
           ]
         ][[2, 1]]
    ]</code></pre>


<p>Then we end define the constructor:</p>
<pre class="prettyprint"><code>OFInit[self_,
   position : {_?NumericQ, _?NumericQ} : {0, 0},
   velocity : {_?NumericQ, _?NumericQ} : {1, 1}
   ] :=

 OFSetThread[self, {&quot;Position&quot;, &quot;Velocity&quot;}, {position, velocity}]</code></pre>


<p>And let’s just peek at the stack:</p>
<pre class="prettyprint"><code>$OFConstructorStack

(*Out:*)

{&lt;|&quot;Name&quot; -&gt; &quot;BallInABox&quot;, &quot;Construct&quot; -&gt; &quot;Type&quot;, 
  &quot;Assign&quot; -&gt; HoldPattern[ballInABox], 
  &quot;Fields&quot; -&gt; &lt;|&quot;ObjectType&quot; -&gt; &quot;Object&quot;, &quot;Box&quot; -&gt; {{-5, 5}, {-5, 5}},
     &quot;ElasticityMultiplier&quot; -&gt; 1|&gt;, 
  &quot;Methods&quot; -&gt; &lt;|&quot;Step&quot; -&gt; &lt;|&quot;Symbol&quot; -&gt; 
       Step$22f15d87fd684683a13e88d69f21dad4, &quot;Properties&quot; -&gt; &lt;||&gt;|&gt;, 
    &quot;ObjectInitialization&quot; -&gt; &lt;|&quot;Symbol&quot; -&gt; 
       ObjectInitialization$4a5647db29784ae69d9b1f0dcd88cddb, 
      &quot;Properties&quot; -&gt; &lt;||&gt;|&gt;|&gt;|&gt;}

OFEnd[]

(*Out:*)</code></pre>


<p><img alt="posts-a-fake-object-framework-5533752296471534441" src="https://www.wolframcloud.com/objects/b3m2a1/home/img/posts-a-fake-object-framework-5533752296471534441.png" /></p>
<p><a id="playing-with-a-ballinabox" >&zwnj;</a></p>
<h2>Playing with a ball-in-a-box</h2>
<p>We’ll then just build one of these objects:</p>
<pre class="prettyprint"><code>ball = ballInABox[RandomReal[{-5, 5}, 2], RandomReal[{-2.5, 2.5}, 2]]

(*Out:*)</code></pre>


<p><img alt="posts-a-fake-object-framework-9116754826795747734" src="https://www.wolframcloud.com/objects/b3m2a1/home/img/posts-a-fake-object-framework-9116754826795747734.png" /></p>
<p>And make it step like 10 times</p>
<pre class="prettyprint"><code>ball[&quot;Step&quot;][10]

(*Out:*)

{{3.08519, 
  0.0352382}, {3.21787, -0.0303612}, {3.35055, -0.0959607}, {3.48323, \
-0.16156}, {3.61591, -0.22716}, {3.74859, -0.292759}, {3.88127, \
-0.358359}, {4.01394, -0.423958}, {4.14662, -0.489558}, {4.2793, \
-0.555157}}</code></pre>


<p>Check the ball’s position and velocity:</p>
<pre class="prettyprint"><code>ball[{&quot;Position&quot;, &quot;Velocity&quot;}]

(*Out:*)

{{2.95251, 0.100838}, {1.32679, -0.655995}}</code></pre>


<p>And view the ball bouncing:</p>
<pre class="prettyprint"><code>With[{box = ball[&quot;Box&quot;]},
  ListAnimate[
    Graphics[Point[#], PlotRange -&gt; box] &amp; /@ ball[&quot;Step&quot;][100]
    ]
  ]

(*Out:*)</code></pre>


<p><img alt="posts-a-fake-object-framework-3943164318078536356" src="https://www.wolframcloud.com/objects/b3m2a1/home/img/posts-a-fake-object-framework-3943164318078536356.gif" /></p>
<p>Randomize the position and velocity and do it again, but faster</p>
<pre class="prettyprint"><code>ball[{&quot;Position&quot;, &quot;Velocity&quot;}] = {RandomReal[{-5, 5}, 2], 
   RandomReal[{-2.5, 2.5}, 2]};
With[{box = ball[&quot;Box&quot;]},
  ListAnimate[
    Graphics[Point[#], PlotRange -&gt; box] &amp; /@ 
   ball[&quot;Step&quot;][Quantity[2, &quot;Seconds&quot;], 100]
    ]
  ]

(*Out:*)</code></pre>


<p><img alt="posts-a-fake-object-framework-6727523626926870660" src="https://www.wolframcloud.com/objects/b3m2a1/home/img/posts-a-fake-object-framework-6727523626926870660.gif" /></p>
<p>This is a basic example of the sort of thing OOP brings to the table and, with enough work, it’s pretty fast and nice enough to work with.</p>
  </div>
</article>
<hr>
<div id="disqus_thread"></div>
<script>
  var disqus_config = function() {
    this.page.url = 'https://www.wolframcloud.com/objects/b3m2a1/home/a-fake-object-framework.html';
      this.page.identifier = 'b3m2a1-home-26119950-8d56-478a-9339-dda09c8ae108';
;
  };
  (function() {
    var d = document;
    var s = d.createElement('script');
    s.src = '//b3m2a1-home.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
  })();
</script>
<noscript class="text-muted">
  Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a>
</noscript>
      </div>
    </div>

  </div>

  <footer class="footer">
    <p class="col-sm-6 text-sm-right text-muted acknowledgement">
      Generated by
      <a href="https://github.com/getpelican/pelican" target="_blank">Pelican</a> /
      Forked from <a href="https://github.com/nairobilug/pelican-alchemy" target="_blank">alchemy</a>
    </p>
  </footer>

</body>

</html>